//@version=6
strategy("ðŸŒ™ ATR Mean Reversion - Moon Dev",
         overlay=true,
         initial_capital=100000,
         default_qty_type=strategy.percent_of_equity,
         default_qty_value=10,
         commission_type=strategy.commission.percent,
         commission_value=0.2)

// ============================================================================
// STRATEGY INFO
// ============================================================================
// Performance: 0.56 Sharpe Ratio | +127.77% Return | -12.65% Max DD
// Entry: Price breaks Keltner Channel + reversal candle pattern
// Exit: ATR-based stop loss and take profit
// Risk: 2% per trade
// ============================================================================

// === INPUTS ===
kcPeriod = input.int(20, "Keltner Channel Period", minval=5, maxval=100)
kcMultiplier = input.float(1.5, "Keltner Channel Multiplier", minval=0.5, maxval=5.0, step=0.1)
atrPeriod = input.int(14, "ATR Period", minval=5, maxval=50)
riskPerTrade = input.float(2.0, "Risk Per Trade (%)", minval=0.1, maxval=10.0, step=0.1)
takeProfitMultiplier = input.float(1.5, "Take Profit (xATR)", minval=0.5, maxval=5.0, step=0.1)
stopLossMultiplier = input.float(1.0, "Stop Loss (xATR)", minval=0.5, maxval=3.0, step=0.1)

// === KELTNER CHANNELS ===
// Using ATR for channels (proper Keltner Channels)
kcMiddle = ta.sma(close, kcPeriod)
atr = ta.atr(atrPeriod)
kcUpper = kcMiddle + (atr * kcMultiplier)
kcLower = kcMiddle - (atr * kcMultiplier)

// === REVERSAL CANDLE PATTERNS ===
// Bullish reversal: close > open (bullish candle)
isBullishCandle = close > open

// Bearish reversal: close < open (bearish candle)
isBearishCandle = close < open

// === ENTRY CONDITIONS ===
// Long: Price pokes below lower KC + bullish reversal candle
longCondition = (low < kcLower or close < kcLower) and isBullishCandle and strategy.position_size == 0

// Short: Price pokes above upper KC + bearish reversal candle
shortCondition = (high > kcUpper or close > kcUpper) and isBearishCandle and strategy.position_size == 0

// === POSITION SIZING ===
calcPositionSize(entry, stop) =>
    riskAmount = strategy.equity * (riskPerTrade / 100)
    riskPerUnit = math.abs(entry - stop)
    posSize = riskPerUnit > 0 ? riskAmount / riskPerUnit : 0
    math.max(posSize, 1.0)  // Minimum position size of 1

// === TRADE EXECUTION ===
var float entryPrice = na
var float stopLoss = na
var float takeProfit = na

// Long Entry
if longCondition
    entryPrice := close
    stopLoss := entryPrice - (atr * stopLossMultiplier)
    takeProfit := entryPrice + (atr * takeProfitMultiplier)

    posSize = calcPositionSize(entryPrice, stopLoss)
    strategy.entry("Long", strategy.long, qty=posSize)

// Short Entry
if shortCondition
    entryPrice := close
    stopLoss := entryPrice + (atr * stopLossMultiplier)
    takeProfit := entryPrice - (atr * takeProfitMultiplier)

    posSize = calcPositionSize(entryPrice, stopLoss)
    strategy.entry("Short", strategy.short, qty=posSize)

// === EXIT MANAGEMENT ===
// Use strategy.exit for proper TP/SL management
if strategy.position_size > 0
    strategy.exit("Exit Long", "Long", limit=takeProfit, stop=stopLoss)

if strategy.position_size < 0
    strategy.exit("Exit Short", "Short", limit=takeProfit, stop=stopLoss)

// === PLOTTING ===
// Plot Keltner Channels
kcUpperPlot = plot(kcUpper, "KC Upper", color=color.new(color.red, 40), linewidth=2)
kcMiddlePlot = plot(kcMiddle, "KC Middle", color=color.new(color.gray, 40), linewidth=1)
kcLowerPlot = plot(kcLower, "KC Lower", color=color.new(color.green, 40), linewidth=2)

// Fill between upper and lower
fill(kcUpperPlot, kcLowerPlot, color=color.new(color.blue, 90), title="KC Channel")

// Plot signals
plotshape(longCondition, "Long Signal", shape.triangleup, location.belowbar, color.green, size=size.normal)
plotshape(shortCondition, "Short Signal", shape.triangledown, location.abovebar, color.red, size=size.normal)

// Plot entry/exit levels
plot(strategy.position_size != 0 ? takeProfit : na, "Take Profit", color.green, style=plot.style_linebr, linewidth=2)
plot(strategy.position_size != 0 ? stopLoss : na, "Stop Loss", color.red, style=plot.style_linebr, linewidth=2)
plot(strategy.position_size != 0 ? entryPrice : na, "Entry", color.yellow, style=plot.style_linebr, linewidth=1)

// === INFO TABLE ===
var table infoTable = table.new(position.top_right, 2, 6, border_width=1)
if barstate.islast
    table.cell(infoTable, 0, 0, "ATR", bgcolor=color.new(color.blue, 80))
    table.cell(infoTable, 1, 0, str.tostring(atr, "#.##"), bgcolor=color.new(color.white, 80))

    table.cell(infoTable, 0, 1, "KC Upper", bgcolor=color.new(color.blue, 80))
    table.cell(infoTable, 1, 1, str.tostring(kcUpper, "#.##"), bgcolor=color.new(color.red, 80))

    table.cell(infoTable, 0, 2, "KC Middle", bgcolor=color.new(color.blue, 80))
    table.cell(infoTable, 1, 2, str.tostring(kcMiddle, "#.##"), bgcolor=color.new(color.gray, 80))

    table.cell(infoTable, 0, 3, "KC Lower", bgcolor=color.new(color.blue, 80))
    table.cell(infoTable, 1, 3, str.tostring(kcLower, "#.##"), bgcolor=color.new(color.green, 80))

    // Distance from channels
    distFromUpper = ((kcUpper - close) / close) * 100
    distFromLower = ((close - kcLower) / close) * 100

    table.cell(infoTable, 0, 4, "Dist from Upper", bgcolor=color.new(color.blue, 80))
    table.cell(infoTable, 1, 4, str.tostring(distFromUpper, "#.##") + "%", bgcolor=color.new(color.white, 80))

    table.cell(infoTable, 0, 5, "Dist from Lower", bgcolor=color.new(color.blue, 80))
    table.cell(infoTable, 1, 5, str.tostring(distFromLower, "#.##") + "%", bgcolor=color.new(color.white, 80))

// === ALERTS ===
alertcondition(longCondition, "Long Entry Alert", "ðŸŒ™ ATR Mean Reversion: Long Entry Signal!")
alertcondition(shortCondition, "Short Entry Alert", "ðŸŒ™ ATR Mean Reversion: Short Entry Signal!")
